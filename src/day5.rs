fn main()
{
    //part_one();
    part_two()
}

enum Opcode
{
    Add = 1,
    Multiply,
    Input,
    Output,
    JumpIfTrue,
    JumpIfFalse,
    LessThan,
    Equals,
    Quit = 99,
}

enum Mode
{
    Position,
    Immediate,
}

fn get_val_with_mode(vals: &Vec<i32>, mode: i32, i: usize) -> usize
{
    match mode
    {
        mode if mode == Mode::Position  as i32 => *vals.get(i).unwrap_or(&0) as usize,
        mode if mode == Mode::Immediate as i32 => i,
        _                                      => 0,
    }
}

fn part_two()
{
    let input = "3,225,1,225,6,6,1100,1,238,225,104,0,1101,33,37,225,101,6,218,224,1001,224,-82,224,4,224,102,8,223,223,101,7,224,224,1,223,224,223,1102,87,62,225,1102,75,65,224,1001,224,-4875,224,4,224,1002,223,8,223,1001,224,5,224,1,224,223,223,1102,49,27,225,1101,6,9,225,2,69,118,224,101,-300,224,224,4,224,102,8,223,223,101,6,224,224,1,224,223,223,1101,76,37,224,1001,224,-113,224,4,224,1002,223,8,223,101,5,224,224,1,224,223,223,1101,47,50,225,102,43,165,224,1001,224,-473,224,4,224,102,8,223,223,1001,224,3,224,1,224,223,223,1002,39,86,224,101,-7482,224,224,4,224,102,8,223,223,1001,224,6,224,1,223,224,223,1102,11,82,225,1,213,65,224,1001,224,-102,224,4,224,1002,223,8,223,1001,224,6,224,1,224,223,223,1001,14,83,224,1001,224,-120,224,4,224,1002,223,8,223,101,1,224,224,1,223,224,223,1102,53,39,225,1101,65,76,225,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,1107,677,226,224,1002,223,2,223,1005,224,329,101,1,223,223,8,677,226,224,102,2,223,223,1006,224,344,1001,223,1,223,108,677,677,224,1002,223,2,223,1006,224,359,1001,223,1,223,1108,226,677,224,102,2,223,223,1006,224,374,1001,223,1,223,1008,677,226,224,102,2,223,223,1005,224,389,101,1,223,223,7,226,677,224,102,2,223,223,1005,224,404,1001,223,1,223,1007,677,677,224,1002,223,2,223,1006,224,419,101,1,223,223,107,677,226,224,102,2,223,223,1006,224,434,101,1,223,223,7,677,677,224,1002,223,2,223,1005,224,449,101,1,223,223,108,677,226,224,1002,223,2,223,1006,224,464,101,1,223,223,1008,226,226,224,1002,223,2,223,1006,224,479,101,1,223,223,107,677,677,224,1002,223,2,223,1006,224,494,1001,223,1,223,1108,677,226,224,102,2,223,223,1005,224,509,101,1,223,223,1007,226,677,224,102,2,223,223,1005,224,524,1001,223,1,223,1008,677,677,224,102,2,223,223,1005,224,539,1001,223,1,223,1107,677,677,224,1002,223,2,223,1006,224,554,1001,223,1,223,1007,226,226,224,1002,223,2,223,1005,224,569,1001,223,1,223,7,677,226,224,1002,223,2,223,1006,224,584,1001,223,1,223,108,226,226,224,102,2,223,223,1005,224,599,1001,223,1,223,8,677,677,224,102,2,223,223,1005,224,614,1001,223,1,223,1107,226,677,224,102,2,223,223,1005,224,629,1001,223,1,223,8,226,677,224,102,2,223,223,1006,224,644,1001,223,1,223,1108,226,226,224,1002,223,2,223,1006,224,659,101,1,223,223,107,226,226,224,1002,223,2,223,1006,224,674,1001,223,1,223,4,223,99,226".to_string();
    //let input = String::from("1101,100,-1,4,0");//"1,9,10,3,2,3,11,0,99,30,40,50");

    let mut vals: Vec<i32> = input.split(",").map(|s| s.parse().unwrap()).collect();

    let mut i:usize = 0;
    while i < vals.len()
    {
        //println!("{}: {}", i, vals[i]);
        let mut val = vals[i];
        let opcode = val % 100;
        val /= 100;
        let mode1 = val % 10;
        val /= 10;
        let mode2 = val % 10;
        val /= 10;
        let mode3 = val;
        
        let a:usize = get_val_with_mode(&vals, mode1, i+1);
        let b:usize = get_val_with_mode(&vals, mode2, i+2);
        let c:usize = get_val_with_mode(&vals, mode3, i+3);
        
        //let a = *vals.get(i+1).unwrap_or(&0) as usize;
        //let b = match vals.get(i+2) { Some(x) => *x as usize, None => 0, };
        //let c = match vals.get(i+3) { Some(x) => *x as usize, None => 0, };
        
        if      opcode == Opcode::Add         as i32 { vals[c] = vals[a] + vals[b];    i += 4; }
        else if opcode == Opcode::Multiply    as i32 { vals[c] = vals[a] * vals[b];    i += 4; }
        else if opcode == Opcode::Input       as i32 { vals[a] = 5;                    i += 2; }
        else if opcode == Opcode::Output      as i32 { println!("{}", vals[a]);        i += 2; }
        else if opcode == Opcode::JumpIfTrue  as i32 { if vals[a] != 0 { i = vals[b] as usize; } else { i += 3; } }
        else if opcode == Opcode::JumpIfFalse as i32 { if vals[a] == 0 { i = vals[b] as usize; } else { i += 3; } }
        else if opcode == Opcode::LessThan    as i32 { vals[c] = if vals[a] <  vals[b] { 1 } else { 0 }; i += 4; }
        else if opcode == Opcode::Equals      as i32 { vals[c] = if vals[a] == vals[b] { 1 } else { 0 }; i += 4; }
        else if opcode == Opcode::Quit        as i32 { break; }
        else                                         { println!("Invalid opcode!"); break; }
    }
    /*
    println!("***");
    for i in 0..vals.len() {
        println!("{}: {}", i, vals[i]);
    }
    */
}
